<!-- 
  TODO 添加 函数参数解构,
  TODO 添加 解构赋值表达式
-->

# 解构

> 解构是 ES6 中新增额一种语法特性，**解构是一种打破数据结构，将其拆分为更小的过程；或是一个将其理解为是一个结构化赋值。**
> **我们可以将数组或者对象属性中带索引的值手动赋值看做是解构化赋值 -- 《你不知道的JavaScript 下卷》**

**使用解构的目的不只是为了打字更少，而是增强代码可读性**

## 对象解构

> 在 ES5 时获取一个对象中的属性值时，往往需要定义多个变量，或是我们获取一个函数的对象返回值，就需要定义一个中间变量。

```js
// ES5 获取对象属性值
var obj = {
  name: 'xhh',
  x: 10,
  y: 20,
  z: 30,
};

var name = obj.name,
    x = obj.x,
    y = obj.y,
    z = obj.z;

// ES6 使用解构获取对象属性
let obj = {
  name: 'xhh',
  x: 10,
  y: 20,
  z: 30,
};

const { name, x, y, z } = obj;
```

通过上面的代码我们看出，解构会更加的简洁方便。在使用解构时，我们同时也可将它的变量名称重新定义且可以添加默认值。**如果需要在不使用 var/let/const 的情况下解构，我们可以将语句使用 () 括号包裹起来。如果不使用括号进行包裹，解析器会将 {} 当作是一个块语句而是不是一个对象。**

```js
// 解构，变量名修改
let obj = {
  name: 'xhh',
  x: 10,
  y: 20,
  z: 30,
};

const { name: firstName, x: X, y: Y, z: Z } = obj;

// 添加默认值

const { name: firstName, x: X, y: Y, z: Z, a: A = 40, b = 50 } = obj;

// 不使用声明标识符
({ name, x, y, z } = obj);
```

结构语法也能够结构嵌套的对象，这也使得我们在获取对象属性值更加的方便了。

```js
const obj = {
  loc: {
    start: {
      line: 1,
      number: 10,
    },
    end: {
      line: 2,
      number: 20,
    },
  },
};

const {loc: { start, end }} = obj;
```

## 数组解构

> 数组解构的使用方式大多与对象解构的使用相差不大，下面将会是一些特别的使用方式。**在数组中使用解构，定义变量会按顺序获取到。**

在我们日常编写代码时，可能会遇到需要更换两个变量的值，这时候我们就可以使用到数组解构的功能了。

```js
// ES5 更换变量值
var a = 10,
    b = 20,
    c;

c = a;
a = b;
b = c;

// ES6 更换变量值
let a = 10,
    b = 20;

[a, b] = [b, a];
[b, a] = [a, b];
```

## 重复赋值

> 在使用解构时，我们对一个属性进行重复的赋值操作。

```js
const { a: X, b: Y } = { a: 10 };

const { a: X, b: Y } = { a: [10] };
X.push(20);
X     // [10, 20]
Y     // [10, 20]
```

## 提示

> 在使用解构时我们需要了解以及需要注意的一些点

1. 在使用 var/let/const 解构声明变量时，必须要要有初始化程序（也就是等号右侧的值）。如果没有初始化程序，则会报错。这可能是由于解析器会将 {} 当作是一个块语句而是不是一个对象。

```js
var { a, b, c };   // Error
let { a, b, c };   // Error
const { a, b, c }; // Error
```

2. 结构赋值表达式（等号右侧的表达式）如果为 `null` 或 `undefined` 会导致程序抛出错误。也就是说，任何尝试读取 `null` 或 `undefined` 属性的行为都会触发语法错误。

```js
const { a, b } = null;        // Error
const { a, b } = undefined;   // Error
```

3. 在使用嵌套结构的功能是需要注意，你可能会在无意之间创建了一个无效的表达式，内空花括号在对象解构中是合法的。

```js
const { loc: {} } = obj;
```

在上述这条语句中，由于右侧只有一对花括号，因而不会声明任何的绑定。
